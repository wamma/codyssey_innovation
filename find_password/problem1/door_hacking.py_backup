import argparse
import itertools
import multiprocessing as mp
import os
import string
import time
import zipfile
from typing import Generator, List, Tuple, Optional


def _try_password(zf: zipfile.ZipFile, member: str, candidate: str) -> bool:
    try:
        with zf.open(member, pwd=candidate.encode('utf-8')) as f:
            _ = f.read(1)  # 1ë°”ì´íŠ¸ë§Œ ì½ì–´ì„œ ë¹ ë¥´ê²Œ ê²€ì¦
        return True
    except Exception:
        return False


def _get_smallest_member(zf: zipfile.ZipFile) -> str:
    members = zf.namelist()
    if not members:
        raise ValueError("ZIP íŒŒì¼ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤")
    
    smallest = members[0]
    smallest_size = zf.getinfo(smallest).file_size
    
    for member in members[1:]:
        size = zf.getinfo(member).file_size
        if size < smallest_size:
            smallest = member
            smallest_size = size
    
    return smallest


def _print_progress(start_ts: float, attempts: int, last_try: str, print_every: int):
    """ì§„í–‰ìƒí™©ì„ ì¶œë ¥"""
    if attempts % print_every != 0:
        return
    
    elapsed = time.time() - start_ts
    speed = attempts / elapsed if elapsed > 0 else 0.0
    start_time_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(start_ts))
    
    print(f'[progress] started={start_time_str} attempts={attempts:,} '
          f'elapsed={elapsed:.1f}s speed={speed:,.0f}/s last="{last_try}"', flush=True)


def _generate_candidates_basic() -> Generator[str, None, None]:
    charset = string.digits + string.ascii_lowercase  # 0-9a-z
    for candidate in itertools.product(charset, repeat=6):
        yield ''.join(candidate)


def _generate_candidates_smart(mask: Optional[str] = None) -> Generator[str, None, None]:
    charset = string.digits + string.ascii_lowercase
    
    if mask:
        # ë§ˆìŠ¤í¬ê°€ ì§€ì •ëœ ê²½ìš° (d=digit, l=lowercase, a=any)
        yield from _generate_from_mask(mask)
        return
    
    # ìš°ì„ ìˆœìœ„ ê¸°ë°˜ íƒìƒ‰ - ìˆ˜ì •ëœ ë²„ì „
    # 1. ìˆ«ì 6ìë¦¬ ë¨¼ì €
    print("[smart] ìˆ«ì 6ìë¦¬ íŒ¨í„´ íƒìƒ‰ ì¤‘...")
    for candidate in itertools.product(string.digits, repeat=6):
        yield ''.join(candidate)
    
    # 2. ì†Œë¬¸ì 6ìë¦¬
    print("[smart] ì†Œë¬¸ì 6ìë¦¬ íŒ¨í„´ íƒìƒ‰ ì¤‘...")
    for candidate in itertools.product(string.ascii_lowercase, repeat=6):
        yield ''.join(candidate)
    
    # 3. í˜¼í•© íŒ¨í„´ë“¤ - ìˆ«ì ê°œìˆ˜ë³„ë¡œ ì²´ê³„ì  íƒìƒ‰
    for num_digits in range(1, 6):  # 1~5ê°œ ìˆ«ì
        num_letters = 6 - num_digits
        print(f"[smart] ìˆ«ì {num_digits}ê°œ + ì†Œë¬¸ì {num_letters}ê°œ íŒ¨í„´ íƒìƒ‰ ì¤‘...")
        
        # ìˆ«ìì™€ ì†Œë¬¸ìì˜ ìœ„ì¹˜ ì¡°í•© ìƒì„±
        positions = list(range(6))
        for digit_positions in itertools.combinations(positions, num_digits):
            letter_positions = [i for i in positions if i not in digit_positions]
            
            # ê° ìœ„ì¹˜ì— ëŒ€í•´ ë¬¸ì ì¡°í•© ìƒì„±
            for digits in itertools.product(string.digits, repeat=num_digits):
                for letters in itertools.product(string.ascii_lowercase, repeat=num_letters):
                    candidate = [''] * 6
                    for i, pos in enumerate(digit_positions):
                        candidate[pos] = digits[i]
                    for i, pos in enumerate(letter_positions):
                        candidate[pos] = letters[i]
                    yield ''.join(candidate)


def _generate_from_mask(mask: str) -> Generator[str, None, None]:
    charsets = []
    for char in mask:
        if char == 'd':
            charsets.append(string.digits)
        elif char == 'l':
            charsets.append(string.ascii_lowercase)
        elif char == 'a':
            charsets.append(string.digits + string.ascii_lowercase)
        else:
            raise ValueError(f"ì˜ëª»ëœ ë§ˆìŠ¤í¬ ë¬¸ì: {char}")
    
    for candidate in itertools.product(*charsets):
        yield ''.join(candidate)


def _matches_any_pattern(candidate: str, patterns: List[str]) -> bool:
    for pattern in patterns:
        if _matches_pattern(candidate, pattern):
            return True
    return False


def _matches_pattern(candidate: str, pattern: str) -> bool:
    if len(candidate) != len(pattern):
        return False
    
    for c, p in zip(candidate, pattern):
        if p == 'd' and not c.isdigit():
            return False
        elif p == 'l' and not c.islower():
            return False
        elif p == 'a':
            continue  # any character is OK
    return True


def _base36_to_string(num: int, length: int = 6) -> str:
    charset = string.digits + string.ascii_lowercase
    result = []
    
    for _ in range(length):
        result.append(charset[num % 36])
        num //= 36
    
    return ''.join(reversed(result))


def _worker_process(args: Tuple) -> Optional[str]:
    """ë©€í‹°í”„ë¡œì„¸ì‹± ì›Œì»¤ í”„ë¡œì„¸ìŠ¤"""
    zip_path, member, start_idx, stride, max_attempts, print_every = args
    
    try:
        with zipfile.ZipFile(zip_path, 'r') as zf:
            attempts = 0
            current_idx = start_idx
            
            while attempts < max_attempts:
                candidate = _base36_to_string(current_idx)
                attempts += 1
                
                if _try_password(zf, member, candidate):
                    return candidate
                
                if print_every > 0 and attempts % print_every == 0:
                    print(f'[worker-{start_idx}] attempts={attempts:,} last="{candidate}"', flush=True)
                
                current_idx += stride
                
                # 36^6ì„ ë„˜ì–´ê°€ë©´ ì¤‘ë‹¨
                if current_idx >= 36**6:
                    break
                    
    except Exception as e:
        print(f'[worker-{start_idx}] ì˜¤ë¥˜: {e}')
    
    return None


def unlock_zip(zip_path: str = 'emergency_storage_key.zip', 
               mode: str = 'basic', 
               workers: int = None, 
               print_every: int = 1000, 
               mask: str = None) -> Optional[str]:
    if not os.path.exists(zip_path):
        print(f"ì˜¤ë¥˜: ZIP íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {zip_path}")
        return None
    
    try:
        with zipfile.ZipFile(zip_path, 'r') as zf:
            member = _get_smallest_member(zf)
            print(f"ëŒ€ìƒ ZIP: {zip_path}")
            print(f"í…ŒìŠ¤íŠ¸ íŒŒì¼: {member} ({zf.getinfo(member).file_size} bytes)")
            print(f"íƒìƒ‰ ëª¨ë“œ: {mode}")
            
            start_time = time.time()
            attempts = 0
            
            if mode == 'basic':
                print("ì™„ì „íƒìƒ‰ ëª¨ë“œë¡œ ì‹œì‘í•©ë‹ˆë‹¤...")
                candidates = _generate_candidates_basic()
                
                for candidate in candidates:
                    attempts += 1
                    
                    if _try_password(zf, member, candidate):
                        elapsed = time.time() - start_time
                        print(f"\nğŸ‰ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤!")
                        print(f"ë¹„ë°€ë²ˆí˜¸: {candidate}")
                        print(f"ì‹œë„ íšŸìˆ˜: {attempts:,}")
                        print(f"ì†Œìš” ì‹œê°„: {elapsed:.2f}ì´ˆ")
                        print(f"í‰ê·  ì†ë„: {attempts/elapsed:,.0f} ì‹œë„/ì´ˆ")
                        
                        # password.txtì— ì €ì¥
                        with open('password.txt', 'w') as f:
                            f.write(candidate)
                        print("ë¹„ë°€ë²ˆí˜¸ë¥¼ password.txtì— ì €ì¥í–ˆìŠµë‹ˆë‹¤.")
                        
                        return candidate
                    
                    _print_progress(start_time, attempts, candidate, print_every)
            
            elif mode == 'smart':
                print("ìŠ¤ë§ˆíŠ¸ íƒìƒ‰ ëª¨ë“œë¡œ ì‹œì‘í•©ë‹ˆë‹¤...")
                if mask:
                    print(f"ë§ˆìŠ¤í¬: {mask}")
                
                candidates = _generate_candidates_smart(mask)
                
                for candidate in candidates:
                    attempts += 1
                    
                    if _try_password(zf, member, candidate):
                        elapsed = time.time() - start_time
                        print(f"\n ë¹„ë°€ë²ˆí˜¸ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤!")
                        print(f"ë¹„ë°€ë²ˆí˜¸: {candidate}")
                        print(f"ì‹œë„ íšŸìˆ˜: {attempts:,}")
                        print(f"ì†Œìš” ì‹œê°„: {elapsed:.2f}ì´ˆ")
                        print(f"í‰ê·  ì†ë„: {attempts/elapsed:,.0f} ì‹œë„/ì´ˆ")
                        
                        # password.txtì— ì €ì¥
                        with open('password.txt', 'w') as f:
                            f.write(candidate)
                        print("ë¹„ë°€ë²ˆí˜¸ë¥¼ password.txtì— ì €ì¥í–ˆìŠµë‹ˆë‹¤.")
                        
                        return candidate
                    
                    _print_progress(start_time, attempts, candidate, print_every)
            
            elif mode == 'mp':
                if workers is None:
                    workers = max(1, mp.cpu_count() - 1)
                
                print(f"ë©€í‹°í”„ë¡œì„¸ì‹± ëª¨ë“œë¡œ ì‹œì‘í•©ë‹ˆë‹¤... (ì›Œì»¤: {workers}ê°œ)")
                
                # ì „ì²´ ê³µê°„ì„ ì›Œì»¤ ìˆ˜ë§Œí¼ ë¶„í• 
                max_space = 36**6
                max_attempts_per_worker = max_space // workers + 1
                
                # ì›Œì»¤ í”„ë¡œì„¸ìŠ¤ ì¸ìˆ˜ ì¤€ë¹„
                worker_args = []
                for i in range(workers):
                    args = (zip_path, member, i, workers, max_attempts_per_worker, print_every)
                    worker_args.append(args)
                
                # ë©€í‹°í”„ë¡œì„¸ì‹± ì‹¤í–‰
                with mp.Pool(workers) as pool:
                    results = pool.map(_worker_process, worker_args)
                
                # ê²°ê³¼ í™•ì¸
                for result in results:
                    if result:
                        elapsed = time.time() - start_time
                        print(f"\n ë¹„ë°€ë²ˆí˜¸ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤!")
                        print(f"ë¹„ë°€ë²ˆí˜¸: {result}")
                        print(f"ì†Œìš” ì‹œê°„: {elapsed:.2f}ì´ˆ")
                        
                        # password.txtì— ì €ì¥
                        with open('password.txt', 'w') as f:
                            f.write(result)
                        print("ë¹„ë°€ë²ˆí˜¸ë¥¼ password.txtì— ì €ì¥í–ˆìŠµë‹ˆë‹¤.")
                        
                        return result
            
            else:
                print(f"ì˜¤ë¥˜: ì•Œ ìˆ˜ ì—†ëŠ” ëª¨ë“œ: {mode}")
                return None
            
            print("\në¹„ë°€ë²ˆí˜¸ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
            return None
            
    except zipfile.BadZipFile:
        print(f"ì˜¤ë¥˜: ì˜¬ë°”ë¥¸ ZIP íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤: {zip_path}")
        return None
    except Exception as e:
        print(f"ì˜¤ë¥˜: {e}")
        return None


def main():
    """ë‹¨ìˆœí™”ëœ ë©”ì¸ í•¨ìˆ˜ - ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œ ZIP íŒŒì¼ í•´í‚¹ ì‹¤í–‰"""
    zip_path = 'emergency_storage_key.zip'
    
    print("=== ZIP ë¹„ë°€ë²ˆí˜¸ í¬ë˜í‚¹ ë„êµ¬ ===")
    print(f"ëŒ€ìƒ íŒŒì¼: {zip_path}")
    
    if not os.path.exists(zip_path):
        print(f"ì˜¤ë¥˜: ZIP íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {zip_path}")
        return
    
    # ìŠ¤ë§ˆíŠ¸ ëª¨ë“œë¡œ ë¹„ë°€ë²ˆí˜¸ ì°¾ê¸° ì‹œë„
    password = unlock_zip(
        zip_path=zip_path,
        mode='smart',
        workers=None,  # ìë™ìœ¼ë¡œ CPU ì½”ì–´ ìˆ˜ ê²°ì •
        print_every=1000,
        mask=None
    )
    
    if password:
        print(f"\nğŸ‰ ì„±ê³µì ìœ¼ë¡œ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤: {password}")
    else:
        print("\nâŒ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")


if __name__ == '__main__':
    main()
